<dec f='include/wayland-client-protocol.h' l='820' type='const struct wl_interface'/>
<use f='include/wayland-client-protocol.h' l='5579' u='a' c='_ZL31wl_subcompositor_get_subsurfaceP16wl_subcompositorP10wl_surfaceS2_'/>
<dec f='include/wayland-server-protocol.h' l='823' type='const struct wl_interface'/>
<def f='include/wayland-server-protocol.h' l='4362' ll='4480'/>
<size>48</size>
<doc f='include/wayland-client-protocol.h' l='767'>/**
 * @defgroup iface_wl_subsurface The wl_subsurface interface
 *
 * An additional interface to a wl_surface object, which has been
 * made a sub-surface. A sub-surface has one parent surface. A
 * sub-surface&apos;s size and position are not limited to that of the parent.
 * Particularly, a sub-surface is not automatically clipped to its
 * parent&apos;s area.
 *
 * A sub-surface becomes mapped, when a non-NULL wl_buffer is applied
 * and the parent surface is mapped. The order of which one happens
 * first is irrelevant. A sub-surface is hidden if the parent becomes
 * hidden, or if a NULL wl_buffer is applied. These rules apply
 * recursively through the tree of surfaces.
 *
 * The behaviour of a wl_surface.commit request on a sub-surface
 * depends on the sub-surface&apos;s mode. The possible modes are
 * synchronized and desynchronized, see methods
 * wl_subsurface.set_sync and wl_subsurface.set_desync. Synchronized
 * mode caches the wl_surface state to be applied when the parent&apos;s
 * state gets applied, and desynchronized mode applies the pending
 * wl_surface state directly. A sub-surface is initially in the
 * synchronized mode.
 *
 * Sub-surfaces have also other kind of state, which is managed by
 * wl_subsurface requests, as opposed to wl_surface requests. This
 * state includes the sub-surface position relative to the parent
 * surface (wl_subsurface.set_position), and the stacking order of
 * the parent and its sub-surfaces (wl_subsurface.place_above and
 * .place_below). This state is applied when the parent surface&apos;s
 * wl_surface state is applied, regardless of the sub-surface&apos;s mode.
 * As the exception, set_sync and set_desync are effective immediately.
 *
 * The main surface can be thought to be always in desynchronized mode,
 * since it does not have a parent in the sub-surfaces sense.
 *
 * Even if a sub-surface is in desynchronized mode, it will behave as
 * in synchronized mode, if its parent surface behaves as in
 * synchronized mode. This rule is applied recursively throughout the
 * tree of surfaces. This means, that one can set a sub-surface into
 * synchronized mode, and then assume that all its child and grand-child
 * sub-surfaces are synchronized, too, without explicitly setting them.
 *
 * If the wl_surface associated with the wl_subsurface is destroyed, the
 * wl_subsurface object becomes inert. Note, that destroying either object
 * takes effect immediately. If you need to synchronize the removal
 * of a sub-surface to the parent surface update, unmap the sub-surface
 * first by attaching a NULL wl_buffer, update parent, and then destroy
 * the sub-surface.
 *
 * If the parent wl_surface object is destroyed, the sub-surface is
 * unmapped.
 */</doc>
<doc f='include/wayland-server-protocol.h' l='770'>/**
 * @defgroup iface_wl_subsurface The wl_subsurface interface
 *
 * An additional interface to a wl_surface object, which has been
 * made a sub-surface. A sub-surface has one parent surface. A
 * sub-surface&apos;s size and position are not limited to that of the parent.
 * Particularly, a sub-surface is not automatically clipped to its
 * parent&apos;s area.
 *
 * A sub-surface becomes mapped, when a non-NULL wl_buffer is applied
 * and the parent surface is mapped. The order of which one happens
 * first is irrelevant. A sub-surface is hidden if the parent becomes
 * hidden, or if a NULL wl_buffer is applied. These rules apply
 * recursively through the tree of surfaces.
 *
 * The behaviour of a wl_surface.commit request on a sub-surface
 * depends on the sub-surface&apos;s mode. The possible modes are
 * synchronized and desynchronized, see methods
 * wl_subsurface.set_sync and wl_subsurface.set_desync. Synchronized
 * mode caches the wl_surface state to be applied when the parent&apos;s
 * state gets applied, and desynchronized mode applies the pending
 * wl_surface state directly. A sub-surface is initially in the
 * synchronized mode.
 *
 * Sub-surfaces have also other kind of state, which is managed by
 * wl_subsurface requests, as opposed to wl_surface requests. This
 * state includes the sub-surface position relative to the parent
 * surface (wl_subsurface.set_position), and the stacking order of
 * the parent and its sub-surfaces (wl_subsurface.place_above and
 * .place_below). This state is applied when the parent surface&apos;s
 * wl_surface state is applied, regardless of the sub-surface&apos;s mode.
 * As the exception, set_sync and set_desync are effective immediately.
 *
 * The main surface can be thought to be always in desynchronized mode,
 * since it does not have a parent in the sub-surfaces sense.
 *
 * Even if a sub-surface is in desynchronized mode, it will behave as
 * in synchronized mode, if its parent surface behaves as in
 * synchronized mode. This rule is applied recursively throughout the
 * tree of surfaces. This means, that one can set a sub-surface into
 * synchronized mode, and then assume that all its child and grand-child
 * sub-surfaces are synchronized, too, without explicitly setting them.
 *
 * If the wl_surface associated with the wl_subsurface is destroyed, the
 * wl_subsurface object becomes inert. Note, that destroying either object
 * takes effect immediately. If you need to synchronize the removal
 * of a sub-surface to the parent surface update, unmap the sub-surface
 * first by attaching a NULL wl_buffer, update parent, and then destroy
 * the sub-surface.
 *
 * If the parent wl_surface object is destroyed, the sub-surface is
 * unmapped.
 */</doc>
<doc f='include/wayland-server-protocol.h' l='4358'>/**
 * @ingroup iface_wl_subsurface
 * @struct wl_subsurface_interface
 */</doc>
<mbr r='wl_subsurface_interface::destroy' o='0' t='void (*)(struct wl_client *, struct wl_resource *)'/>
<mbr r='wl_subsurface_interface::set_position' o='64' t='void (*)(struct wl_client *, struct wl_resource *, int32_t, int32_t)'/>
<mbr r='wl_subsurface_interface::place_above' o='128' t='void (*)(struct wl_client *, struct wl_resource *, struct wl_resource *)'/>
<mbr r='wl_subsurface_interface::place_below' o='192' t='void (*)(struct wl_client *, struct wl_resource *, struct wl_resource *)'/>
<mbr r='wl_subsurface_interface::set_sync' o='256' t='void (*)(struct wl_client *, struct wl_resource *)'/>
<mbr r='wl_subsurface_interface::set_desync' o='320' t='void (*)(struct wl_client *, struct wl_resource *)'/>
