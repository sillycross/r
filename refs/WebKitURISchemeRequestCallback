<doc f='WebKit/Source/WebKit/UIProcess/API/glib/WebKitWebContext.cpp' l='1203'>/**
 * webkit_web_context_register_uri_scheme:
 * @context: a #WebKitWebContext
 * @scheme: the network scheme to register
 * @callback: (scope async): a #WebKitURISchemeRequestCallback
 * @user_data: data to pass to callback function
 * @user_data_destroy_func: destroy notify for @user_data
 *
 * Register @scheme in @context, so that when an URI request with @scheme is made in the
 * #WebKitWebContext, the #WebKitURISchemeRequestCallback registered will be called with a
 * #WebKitURISchemeRequest.
 * It is possible to handle URI scheme requests asynchronously, by calling g_object_ref() on the
 * #WebKitURISchemeRequest and calling webkit_uri_scheme_request_finish() later
 * when the data of the request is available or
 * webkit_uri_scheme_request_finish_error() in case of error.
 *
 * &lt;informalexample&gt;&lt;programlisting&gt;
 * static void
 * about_uri_scheme_request_cb (WebKitURISchemeRequest *request,
 *                              gpointer                user_data)
 * {
 *     GInputStream *stream;
 *     gsize         stream_length;
 *     const gchar  *path;
 *
 *     path = webkit_uri_scheme_request_get_path (request);
 *     if (!g_strcmp0 (path, &quot;memory&quot;)) {
 *         /&lt;!-- --&gt;* Create a GInputStream with the contents of memory about page, and set its length to stream_length *&lt;!-- --&gt;/
 *     } else if (!g_strcmp0 (path, &quot;applications&quot;)) {
 *         /&lt;!-- --&gt;* Create a GInputStream with the contents of applications about page, and set its length to stream_length *&lt;!-- --&gt;/
 *     } else if (!g_strcmp0 (path, &quot;example&quot;)) {
 *         gchar *contents;
 *
 *         contents = g_strdup_printf (&quot;&amp;lt;html&amp;gt;&amp;lt;body&amp;gt;&amp;lt;p&amp;gt;Example about page&amp;lt;/p&amp;gt;&amp;lt;/body&amp;gt;&amp;lt;/html&amp;gt;&quot;);
 *         stream_length = strlen (contents);
 *         stream = g_memory_input_stream_new_from_data (contents, stream_length, g_free);
 *     } else {
 *         GError *error;
 *
 *         error = g_error_new (ABOUT_HANDLER_ERROR, ABOUT_HANDLER_ERROR_INVALID, &quot;Invalid about:%s page.&quot;, path);
 *         webkit_uri_scheme_request_finish_error (request, error);
 *         g_error_free (error);
 *         return;
 *     }
 *     webkit_uri_scheme_request_finish (request, stream, stream_length, &quot;text/html&quot;);
 *     g_object_unref (stream);
 * }
 * &lt;/programlisting&gt;&lt;/informalexample&gt;
 */</doc>
