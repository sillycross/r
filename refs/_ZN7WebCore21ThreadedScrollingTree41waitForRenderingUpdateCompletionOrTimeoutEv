<dec f='WebKit/Source/WebCore/page/scrolling/ThreadedScrollingTree.h' l='90' type='void WebCore::ThreadedScrollingTree::waitForRenderingUpdateCompletionOrTimeout()'/>
<use f='WebKit/Source/WebCore/page/scrolling/ThreadedScrollingTree.cpp' l='291' u='c' c='_ZN7WebCore21ThreadedScrollingTree24willStartRenderingUpdateEv'/>
<def f='WebKit/Source/WebCore/page/scrolling/ThreadedScrollingTree.cpp' l='313' ll='340' type='void WebCore::ThreadedScrollingTree::waitForRenderingUpdateCompletionOrTimeout()'/>
<doc f='WebKit/Source/WebCore/page/scrolling/ThreadedScrollingTree.cpp' l='307'>// This code allows the main thread about half a frame to complete its rendering udpate. If the main thread
// is responsive (i.e. managing to render every frame), then we expect to get a didCompleteRenderingUpdate()
// within 8ms of willStartRenderingUpdate(). We time this via m_stateCondition, which blocks the scrolling
// thread (with m_treeLock locked at the start and end) so that we don&apos;t handle wheel events while waiting.
// If the condition times out, we know the main thread is being slow, and allow the scrolling thread to
// commit layer positions.</doc>
