<dec f='WebKit/Source/WebCore/page/scrolling/ScrollingMomentumCalculator.h' l='72' type='void WebCore::BasicScrollingMomentumCalculator::initializeSnapProgressCurve()'/>
<use f='WebKit/Source/WebCore/page/scrolling/ScrollingMomentumCalculator.cpp' l='106' u='c' c='_ZN7WebCore32BasicScrollingMomentumCalculator28scrollOffsetAfterElapsedTimeEN3WTF7SecondsE'/>
<def f='WebKit/Source/WebCore/page/scrolling/ScrollingMomentumCalculator.cpp' l='202' ll='227' type='void WebCore::BasicScrollingMomentumCalculator::initializeSnapProgressCurve()'/>
<doc f='WebKit/Source/WebCore/page/scrolling/ScrollingMomentumCalculator.cpp' l='177'>/**
 * Computes and sets parameters required for tracking the progress of a snap animation curve, interpolated
 * or linear. The progress curve s(t) maps time t to progress s; both variables are in the interval [0, 1].
 * The time input t is 0 when the current time is the start of the animation, t = 0, and 1 when the current
 * time is at or after the end of the animation, t = m_scrollSnapAnimationDuration.
 *
 * In this exponential progress model, s(t) = A - A * b^(-kt), where k = 60T is the number of frames in the
 * animation (assuming 60 FPS and an animation duration of T) and A, b are reals greater than or equal to 1.
 * Also note that we are given the initial progress, a value indicating the portion of the curve which our
 * initial scroll delta takes us. This is important when matching the initial speed of the animation to the
 * user&apos;s initial momentum scrolling speed. Let this initial progress amount equal v_0. I clamp this initial
 * progress amount to a minimum or maximum value.
 *
 * A is referred to as the curve magnitude, while b is referred to as the decay factor. We solve for A and b,
 * keeping the following constraints in mind:
 *     1. s(0) = 0
 *     2. s(1) = 1
 *     3. s(1/k) = v_0
 *
 * First, observe that s(0) = 0 holds for appropriate values of A, b. Solving for the remaining constraints
 * yields a nonlinear system of two equations. In lieu of a purely analytical solution, an alternating
 * optimization scheme is used to approximate A and b. This technique converges quickly (within 5 iterations
 * or so) for appropriate values of v_0. The optimization terminates early when the decay factor changes by
 * less than a threshold between one iteration and the next.
 */</doc>
