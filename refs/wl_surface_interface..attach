<dec f='include/wayland-server-protocol.h' l='2832' type='void (*)(struct wl_client *, struct wl_resource *, struct wl_resource *, int32_t, int32_t)'/>
<offset>64</offset>
<doc f='include/wayland-server-protocol.h' l='2778'>/**
	 * set the surface contents
	 *
	 * Set a buffer as the content of this surface.
	 *
	 * The new size of the surface is calculated based on the buffer
	 * size transformed by the inverse buffer_transform and the inverse
	 * buffer_scale. This means that the supplied buffer must be an
	 * integer multiple of the buffer_scale.
	 *
	 * The x and y arguments specify the location of the new pending
	 * buffer&apos;s upper left corner, relative to the current buffer&apos;s
	 * upper left corner, in surface-local coordinates. In other words,
	 * the x and y, combined with the new surface size define in which
	 * directions the surface&apos;s size changes.
	 *
	 * Surface contents are double-buffered state, see
	 * wl_surface.commit.
	 *
	 * The initial surface contents are void; there is no content.
	 * wl_surface.attach assigns the given wl_buffer as the pending
	 * wl_buffer. wl_surface.commit makes the pending wl_buffer the new
	 * surface contents, and the size of the surface becomes the size
	 * calculated from the wl_buffer, as described above. After commit,
	 * there is no pending buffer until the next attach.
	 *
	 * Committing a pending wl_buffer allows the compositor to read the
	 * pixels in the wl_buffer. The compositor may access the pixels at
	 * any time after the wl_surface.commit request. When the
	 * compositor will not access the pixels anymore, it will send the
	 * wl_buffer.release event. Only after receiving wl_buffer.release,
	 * the client may reuse the wl_buffer. A wl_buffer that has been
	 * attached and then replaced by another attach instead of
	 * committed will not receive a release event, and is not used by
	 * the compositor.
	 *
	 * If a pending wl_buffer has been committed to more than one
	 * wl_surface, the delivery of wl_buffer.release events becomes
	 * undefined. A well behaved client should not rely on
	 * wl_buffer.release events in this case. Alternatively, a client
	 * could create multiple wl_buffer objects from the same backing
	 * storage or use wp_linux_buffer_release.
	 *
	 * Destroying the wl_buffer after wl_buffer.release does not change
	 * the surface contents. However, if the client destroys the
	 * wl_buffer before receiving the wl_buffer.release event, the
	 * surface contents become undefined immediately.
	 *
	 * If wl_surface.attach is sent with a NULL wl_buffer, the
	 * following wl_surface.commit will remove the surface content.
	 * @param buffer buffer of surface contents
	 * @param x surface-local x coordinate
	 * @param y surface-local y coordinate
	 */</doc>
