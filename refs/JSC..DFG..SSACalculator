<def f='WebKit/Source/JavaScriptCore/dfg/DFGSSACalculator.h' l='102' ll='255'/>
<use f='WebKit/Source/JavaScriptCore/dfg/DFGSSACalculator.h' l='117'/>
<use f='WebKit/Source/JavaScriptCore/dfg/DFGSSACalculator.h' l='143'/>
<use f='WebKit/Source/JavaScriptCore/dfg/DFGObjectAllocationSinkingPhase.cpp' l='2648'/>
<use f='WebKit/Source/JavaScriptCore/dfg/DFGObjectAllocationSinkingPhase.cpp' l='2649'/>
<size>64</size>
<doc f='WebKit/Source/JavaScriptCore/dfg/DFGSSACalculator.h' l='35'>// SSACalculator provides a reusable tool for using the Cytron, Ferrante, Rosen, Wegman, and
// Zadeck &quot;Efficiently Computing Static Single Assignment Form and the Control Dependence Graph&quot;
// (TOPLAS&apos;91) algorithm for computing SSA. SSACalculator doesn&apos;t magically do everything for you
// but it maintains the major data structures and handles most of the non-local reasoning. Here&apos;s
// the workflow of using SSACalculator to execute this algorithm:
//
// 0) Create a fresh SSACalculator instance. You will need this instance only for as long as
//    you&apos;re not yet done computing SSA.
//
// 1) Create an SSACalculator::Variable for every variable that you want to do Phi insertion
//    on. SSACalculator::Variable::index() is a dense indexing of the Variables that you
//    created, so you can easily use a Vector to map the SSACalculator::Variables to your
//    variables.
//
// 2) Create a SSACalculator::Def for every assignment to those variables. A Def knows about the
//    variable, the block, and the DFG::Node* that has the value being put into the variable.
//    Note that creating a Def in block B for variable V if block B already has a def for variable
//    V will overwrite the previous Def&apos;s DFG::Node* value. This enables you to create Defs by
//    processing basic blocks in forward order. If a block has multiple Defs of a variable, this
//    &quot;just works&quot; because each block will then remember the last Def of each variable.
//
// 3) Call SSACalculator::computePhis(). This takes a functor that will create the Phi nodes. The
//    functor returns either the Phi node it created, or nullptr, if it chooses to prune. (As an
//    aside, it&apos;s always sound not to prune, and the safest reason for pruning is liveness.) The
//    computePhis() code will record the created Phi nodes as Defs, and it will separately record
//    the list of Phis inserted at each block. It&apos;s OK for the functor you pass here to modify the
//    DFG::Graph on the fly, but the easiest way to write this is to just create the Phi nodes by
//    doing Graph::addNode() and return them. It&apos;s then best to insert all Phi nodes for a block
//    in bulk as part of the pass you do below, in step (4).
//
// 4) Modify the graph to create the SSA data flow. For each block, this should:
//
//    4.0) Compute the set of reaching defs (aka available values) for each variable by calling
//         SSACalculator::reachingDefAtHead() for each variable. Record this in a local table that
//         will be incrementally updated as you proceed through the block in forward order in the
//         next steps:
//
//         FIXME: It might be better to compute reaching defs for all live variables in one go, to
//         avoid doing repeated dom tree traversals.
//         https://bugs.webkit.org/show_bug.cgi?id=136610
//
//    4.1) Insert all of the Phi nodes for the block by using SSACalculator::phisForBlock(), and
//         record those Phi nodes as being available values.
//
//    4.2) Process the block in forward order. For each load from a variable, replace it with the
//         available SSA value for that variable. For each store, delete it and record the stored
//         value as being available.
//
//         Note that you have two options of how to replace loads with SSA values. You can replace
//         the load with an Identity node; this will end up working fairly naturally so long as
//         you run GCSE after your phase. Or, you can replace all uses of the load with the SSA
//         value yourself (using the Graph::performSubstitution() idiom), but that requires that
//         your loop over basic blocks proceeds in the appropriate graph order, for example
//         preorder.
//
//         FIXME: Make it easier to do this, that doesn&apos;t involve rerunning GCSE.
//         https://bugs.webkit.org/show_bug.cgi?id=136639
//
//    4.3) Insert Upsilons at the end of the current block for the corresponding Phis in each successor block. 
//         Use the available values table to decide the source value for each Phi&apos;s variable. Note that 
//         you could also use SSACalculator::reachingDefAtTail() instead of the available values table, 
//         though your local available values table is likely to be more efficient.
//
// The most obvious use of SSACalculator is for the CPS-&gt;SSA conversion itself, but it&apos;s meant to
// also be used for SSA update and for things like the promotion of heap fields to local SSA
// variables.</doc>
<fun r='_ZN3JSC3DFG13SSACalculatorC1ERNS0_5GraphE'/>
<fun r='_ZN3JSC3DFG13SSACalculatorD1Ev'/>
<fun r='_ZN3JSC3DFG13SSACalculator5resetEv'/>
<fun r='_ZN3JSC3DFG13SSACalculator11newVariableEv'/>
<fun r='_ZN3JSC3DFG13SSACalculator6newDefEPNS1_8VariableEPNS0_10BasicBlockEPNS0_4NodeE'/>
<fun r='_ZN3JSC3DFG13SSACalculator8variableEj'/>
<fun r='_ZN3JSC3DFG13SSACalculator11computePhisERKT_'/>
<fun r='_ZN3JSC3DFG13SSACalculator12phisForBlockEPNS0_10BasicBlockE'/>
<fun r='_ZN3JSC3DFG13SSACalculator19nonLocalReachingDefEPNS0_10BasicBlockEPNS1_8VariableE'/>
<fun r='_ZN3JSC3DFG13SSACalculator17reachingDefAtHeadEPNS0_10BasicBlockEPNS1_8VariableE'/>
<fun r='_ZN3JSC3DFG13SSACalculator17reachingDefAtTailEPNS0_10BasicBlockEPNS1_8VariableE'/>
<fun r='_ZNK3JSC3DFG13SSACalculator4dumpERN3WTF11PrintStreamE'/>
<mbr r='JSC::DFG::SSACalculator::m_variables' o='0' t='SegmentedVector&lt;JSC::DFG::SSACalculator::Variable&gt;'/>
<mbr r='JSC::DFG::SSACalculator::m_defs' o='192' t='Bag&lt;JSC::DFG::SSACalculator::Def&gt;'/>
<mbr r='JSC::DFG::SSACalculator::m_phis' o='256' t='Bag&lt;JSC::DFG::SSACalculator::Def&gt;'/>
<mbr r='JSC::DFG::SSACalculator::m_data' o='320' t='BlockMap&lt;JSC::DFG::SSACalculator::BlockData&gt;'/>
<mbr r='JSC::DFG::SSACalculator::m_graph' o='448' t='JSC::DFG::Graph &amp;'/>
<use f='WebKit/Source/JavaScriptCore/dfg/DFGPutStackSinkingPhase.cpp' l='79' c='_ZN3JSC3DFG12_GLOBAL__N_120PutStackSinkingPhase3runEv'/>
<use f='WebKit/Source/JavaScriptCore/dfg/DFGSSACalculator.cpp' l='120' c='_ZNK3JSC3DFG13SSACalculator4dumpERN3WTF11PrintStreamE'/>
<use f='WebKit/Source/JavaScriptCore/dfg/DFGSSACalculator.cpp' l='124' c='_ZNK3JSC3DFG13SSACalculator4dumpERN3WTF11PrintStreamE'/>
<use f='WebKit/Source/JavaScriptCore/dfg/DFGSSAConversionPhase.cpp' l='118' c='_ZN3JSC3DFG18SSAConversionPhase3runEv'/>
<size>64</size>
<fun r='_ZN3JSC3DFG13SSACalculatorC1ERNS0_5GraphE'/>
<fun r='_ZN3JSC3DFG13SSACalculatorD1Ev'/>
<fun r='_ZN3JSC3DFG13SSACalculator5resetEv'/>
<fun r='_ZN3JSC3DFG13SSACalculator11newVariableEv'/>
<fun r='_ZN3JSC3DFG13SSACalculator6newDefEPNS1_8VariableEPNS0_10BasicBlockEPNS0_4NodeE'/>
<fun r='_ZN3JSC3DFG13SSACalculator19nonLocalReachingDefEPNS0_10BasicBlockEPNS1_8VariableE'/>
<fun r='_ZN3JSC3DFG13SSACalculator17reachingDefAtTailEPNS0_10BasicBlockEPNS1_8VariableE'/>
<fun r='_ZNK3JSC3DFG13SSACalculator4dumpERN3WTF11PrintStreamE'/>
